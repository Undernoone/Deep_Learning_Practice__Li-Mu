## Convolutional Layer

严格来说，卷积层是个错误的叫法，因为它所表达的运算其实是互相关运算（cross-correlation），而不是卷积运算。

## Convolution Operation

在卷积操作中，卷积核在输入矩阵上移动，并在每个位置进行加权和运算。

### 公式推导

- **输入图像**：大小为 H×W
- **卷积核**：大小为 K×K
- **步幅（Stride）**：卷积核在输入图像上滑动的步长。
- **填充（Padding）**：在输入图像的边缘填充的像素数。

卷积核的每次移动都会计算一个输出像素。步幅 决定了卷积核每次移动的距离。每次卷积核移动时，输出的一个像素是通过以下计算得到的：
$$

\text{输出高度} = \frac{H + 2 \times P - K}{S} + 1
\
\text{输出宽度} = \frac{W + 2 \times P - K}{S} + 1

$$


## Traditional Convolutional Layer Code

```python
# 互相关运算
import torch
from torch import nn
# 定义一个stride=1，padding=0的卷积层
def corr2d(X, K):   # X为输入，K为卷积核
    h, w = K.shape  
    Y = torch.zeros((X.shape[0] - h + 1, X.shape[1] - w + 1))     
    for i in range(Y.shape[0]):
        for j in range(Y.shape[1]):
            Y[i, j] = (X[i:i + h, j:j + w] * K).sum() # 图片的小方块区域与卷积核做点积
    return Y

# 验证上述二维互相关运算的输出
X = torch.tensor([[0.0,1.0,2.0],[3.0,4.0,5.0],[6.0,7.0,8.0]])
K = torch.tensor([[0.0,1.0],[2.0,3.0]])
print(corr2d(X,K))
```